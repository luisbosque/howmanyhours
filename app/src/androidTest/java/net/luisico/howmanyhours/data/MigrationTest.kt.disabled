package net.luisico.howmanyhours.data

import androidx.room.testing.MigrationTestHelper
import androidx.sqlite.db.framework.FrameworkSQLiteOpenHelperFactory
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.platform.app.InstrumentationRegistry
import net.luisico.howmanyhours.data.database.AppDatabase
import org.junit.Assert.*
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import java.io.IOException

/**
 * Migration tests focusing on:
 * - Data preservation across schema changes
 * - Correct schema transformations
 * - Migration chain integrity
 * - No data loss during migrations
 */
@RunWith(AndroidJUnit4::class)
class MigrationTest {

    private val TEST_DB = "migration_test"

    @get:Rule
    val helper: MigrationTestHelper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java,
        emptyList(),
        FrameworkSQLiteOpenHelperFactory()
    )

    // ============ Migration 1 → 2 Tests ============

    @Test
    @Throws(IOException::class)
    fun testMigration1To2AddsNameColumn() {
        // Create database with version 1 schema
        var db = helper.createDatabase(TEST_DB, 1).apply {
            // Insert a project
            execSQL("""
                INSERT INTO projects (id, name, createdAt, isActive)
                VALUES (1, 'Test Project', ${System.currentTimeMillis()}, 1)
            """)

            // Insert time entries without 'name' column (version 1 schema)
            execSQL("""
                INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning)
                VALUES (1, 1, ${System.currentTimeMillis()}, ${System.currentTimeMillis() + 60000}, 0)
            """)

            execSQL("""
                INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning)
                VALUES (2, 1, ${System.currentTimeMillis()}, NULL, 1)
            """)

            close()
        }

        // Run migration 1→2
        db = helper.runMigrationsAndValidate(TEST_DB, 2, true, AppDatabase.MIGRATION_1_2)

        // Verify 'name' column was added
        val cursor = db.query("SELECT * FROM time_entries")

        // Check column exists
        val nameColumnIndex = cursor.getColumnIndex("name")
        assertTrue("name column should exist after migration", nameColumnIndex >= 0)

        // Verify data preserved
        var count = 0
        while (cursor.moveToNext()) {
            count++
            val projectId = cursor.getLong(cursor.getColumnIndexOrThrow("projectId"))

            // Verify original data intact
            assertEquals("projectId should be preserved", 1L, projectId)

            // name should be null for existing entries
            val nameValue = if (!cursor.isNull(nameColumnIndex)) {
                cursor.getString(nameColumnIndex)
            } else null
            assertNull("name should be null for migrated entries", nameValue)
        }
        cursor.close()

        assertEquals("Should have 2 time entries after migration", 2, count)
    }

    @Test
    @Throws(IOException::class)
    fun testMigration1To2PreservesAllData() {
        // Create v1 database with comprehensive data
        var db = helper.createDatabase(TEST_DB, 1).apply {
            // Insert multiple projects
            execSQL("INSERT INTO projects (id, name, createdAt, isActive) VALUES (1, 'Project 1', 1000000, 1)")
            execSQL("INSERT INTO projects (id, name, createdAt, isActive) VALUES (2, 'Project 2', 2000000, 0)")

            // Insert multiple entries
            execSQL("INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning) VALUES (1, 1, 1000000, 1060000, 0)")
            execSQL("INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning) VALUES (2, 1, 2000000, NULL, 1)")
            execSQL("INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning) VALUES (3, 2, 3000000, 3060000, 0)")

            close()
        }

        // Migrate
        db = helper.runMigrationsAndValidate(TEST_DB, 2, true, AppDatabase.MIGRATION_1_2)

        // Verify all entries preserved
        val cursor = db.query("SELECT COUNT(*) FROM time_entries")
        cursor.moveToFirst()
        assertEquals("All time entries should be preserved", 3, cursor.getInt(0))
        cursor.close()

        // Verify all projects preserved
        val projectCursor = db.query("SELECT COUNT(*) FROM projects")
        projectCursor.moveToFirst()
        assertEquals("All projects should be preserved", 2, projectCursor.getInt(0))
        projectCursor.close()
    }

    // ============ Migration 2 → 3 Tests ============

    @Test
    @Throws(IOException::class)
    fun testMigration2To3AddsPeriodTracking() {
        // Create v2 database
        var db = helper.createDatabase(TEST_DB, 2).apply {
            // Insert project (v2 schema - no periodMode)
            execSQL("INSERT INTO projects (id, name, createdAt, isActive) VALUES (1, 'Test Project', 1000000, 1)")

            // Insert time entries (v2 has 'name' column)
            execSQL("INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning, name) VALUES (1, 1, 1000000, 1060000, 0, 'Entry 1')")

            close()
        }

        // Migrate 2→3
        db = helper.runMigrationsAndValidate(TEST_DB, 3, true, AppDatabase.MIGRATION_2_3)

        // Verify periodMode column added to projects
        val projectCursor = db.query("SELECT * FROM projects")
        projectCursor.moveToFirst()

        val periodModeIndex = projectCursor.getColumnIndex("periodMode")
        assertTrue("periodMode column should exist", periodModeIndex >= 0)

        val periodMode = projectCursor.getString(periodModeIndex)
        assertEquals("periodMode should default to 'monthly'", "monthly", periodMode)
        projectCursor.close()

        // Verify period_closes table created
        val tablesCursor = db.query(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='period_closes'"
        )
        assertTrue("period_closes table should exist", tablesCursor.moveToFirst())
        tablesCursor.close()

        // Verify indices created
        val indexCursor = db.query(
            "SELECT name FROM sqlite_master WHERE type='index' AND (name='index_period_closes_projectId' OR name='index_period_closes_closeTime')"
        )

        var indexCount = 0
        while (indexCursor.moveToNext()) {
            indexCount++
        }
        indexCursor.close()

        assertEquals("Should have 2 indices for period_closes", 2, indexCount)
    }

    // ============ Migration 3 → 4 Tests ============

    @Test
    @Throws(IOException::class)
    fun testMigration3To4AddsIndex() {
        // Create v3 database
        var db = helper.createDatabase(TEST_DB, 3).apply {
            execSQL("INSERT INTO projects (id, name, createdAt, isActive, periodMode) VALUES (1, 'Test', 1000000, 1, 'monthly')")
            execSQL("INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning, name) VALUES (1, 1, 1000000, 1060000, 0, 'Entry')")

            close()
        }

        // Migrate 3→4
        db = helper.runMigrationsAndValidate(TEST_DB, 4, true, AppDatabase.MIGRATION_3_4)

        // Verify index was added
        val indexCursor = db.query(
            "SELECT name FROM sqlite_master WHERE type='index' AND name='index_time_entries_projectId'"
        )

        assertTrue("index_time_entries_projectId should exist", indexCursor.moveToFirst())
        indexCursor.close()

        // Verify data still intact
        val entryCursor = db.query("SELECT COUNT(*) FROM time_entries")
        entryCursor.moveToFirst()
        assertEquals("Data should be preserved", 1, entryCursor.getInt(0))
        entryCursor.close()
    }

    @Test
    @Throws(IOException::class)
    fun testMigration3To4PreservesLargeDataset() {
        // Create v3 database with many entries
        var db = helper.createDatabase(TEST_DB, 3).apply {
            execSQL("INSERT INTO projects (id, name, createdAt, isActive, periodMode) VALUES (1, 'Test', 1000000, 1, 'monthly')")

            // Insert 50 entries
            repeat(50) { i ->
                execSQL(
                    "INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning, name) " +
                            "VALUES ($i, 1, ${1000000 + i * 60000}, ${1000000 + i * 60000 + 30000}, 0, 'Entry $i')"
                )
            }

            close()
        }

        // Migrate
        db = helper.runMigrationsAndValidate(TEST_DB, 4, true, AppDatabase.MIGRATION_3_4)

        // Verify all data preserved
        val cursor = db.query("SELECT COUNT(*) FROM time_entries")
        cursor.moveToFirst()
        assertEquals("All 50 entries should be preserved", 50, cursor.getInt(0))
        cursor.close()
    }

    // ============ Full Migration Chain Tests ============

    @Test
    @Throws(IOException::class)
    fun testFullMigrationChain1To4() {
        // Create v1 database
        var db = helper.createDatabase(TEST_DB, 1).apply {
            execSQL("INSERT INTO projects (id, name, createdAt, isActive) VALUES (1, 'Chain Test', 1000000, 1)")
            execSQL("INSERT INTO time_entries (id, projectId, startTime, endTime, isRunning) VALUES (1, 1, 1000000, 1060000, 0)")

            close()
        }

        // Migrate through entire chain: 1→2→3→4
        db = helper.runMigrationsAndValidate(
            TEST_DB,
            4,
            true,
            AppDatabase.MIGRATION_1_2,
            AppDatabase.MIGRATION_2_3,
            AppDatabase.MIGRATION_3_4
        )

        // Verify final schema
        val projectCursor = db.query("SELECT * FROM projects")
        projectCursor.moveToFirst()

        // Should have all v4 columns
        assertTrue("Should have periodMode column", projectCursor.getColumnIndex("periodMode") >= 0)
        assertEquals("periodMode should be monthly", "monthly", projectCursor.getString(projectCursor.getColumnIndex("periodMode")))

        projectCursor.close()

        // Verify time_entries has 'name' column and index
        val entryCursor = db.query("SELECT * FROM time_entries")
        entryCursor.moveToFirst()
        assertTrue("Should have name column", entryCursor.getColumnIndex("name") >= 0)
        entryCursor.close()

        // Verify period_closes table exists
        val tablesCursor = db.query("SELECT name FROM sqlite_master WHERE type='table' AND name='period_closes'")
        assertTrue("Should have period_closes table", tablesCursor.moveToFirst())
        tablesCursor.close()

        // Verify index exists
        val indexCursor = db.query("SELECT name FROM sqlite_master WHERE type='index' AND name='index_time_entries_projectId'")
        assertTrue("Should have projectId index", indexCursor.moveToFirst())
        indexCursor.close()

        // Most importantly: verify original data preserved
        val dataCheck = db.query("SELECT * FROM projects WHERE id = 1")
        dataCheck.moveToFirst()
        assertEquals("Original project name preserved", "Chain Test", dataCheck.getString(dataCheck.getColumnIndex("name")))
        dataCheck.close()

        val entryCheck = db.query("SELECT * FROM time_entries WHERE id = 1")
        entryCheck.moveToFirst()
        assertEquals("Original entry data preserved", 1L, entryCheck.getLong(entryCheck.getColumnIndex("projectId")))
        entryCheck.close()
    }
}
